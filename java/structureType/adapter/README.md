### 适配器模式

### 组成元素

适配器模式(Adapter Pattern)
：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。
适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。这个非常的灵活可以不用定义的那么死板。

Target：目标抽象类
Adapter：适配器类
Adaptee：适配者类

| 元素      | 名称        | 类型             |
|---------|-----------|----------------|
| Target  | 目标抽象类或者接口 | abstract class |
| Adapter | 适配器类      | class          |
| Adaptee | 适配者类      | class          |

### 说明

1. 适配器模式非常的简单和灵活，关于Target
   的实现模式可以是接口也可以是一个abstract class,也可以是一个interface。重点是Adapter对象调用了Adaptee对象的方法，并对Adaptee提供的方法进行适配，从而可以在我们的客户端使用第三方提供的服务。
2. 举例一个例子🌰：一个系统需要调用百度地图功能，那么就需要在百度地图提供的接口服务上进行封装，将自己的逻辑封装出来，那么这个过程就叫
   **适配**
3. 对于适配器和装饰器的**区别**大家可以移步到[这里 「装饰器篇章」](../decorator/README.md)
4. 额外说明：为什么要引入abstract class 多此一举呢？
   1. 因为对于适配者方法的适配来说，这个是其唯一的。假如我们有三个适配器，我们不需要进行三次适配过程，我们将适配过程放到父类就好了，对于适配者方法的增强和具体逻辑我们放在各自的适配器就好了。
   2. 所以这是为什么我们使用abstract class的原因。如果只以接口的形式呈现的话，那么三个适配器就需要三次适配过程。